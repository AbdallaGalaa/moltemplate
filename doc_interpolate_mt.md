interpolate_mt.py
===========

##  Description

"interpolate_mt.py" is a crude program which uses (centripetal Catmull-
Rom) cubic spline interpolation to generate a set of evenly spaced
coordinates which lie along smooth a curve specified by the user.

## Usage

```
interpolate_mt.py Ndesired [scale] < old_coords.raw > new_coords.raw
```

The old_coords.raw and new_coords.raw are 3-column text files containing
x,y,z coordinates.  The new_coords.raw file in this example will contain
"Ndesired" coordinates distributed along the path whose control points are
stored in the file "old_coords.raw".  The optional "scale" parameter will
cause the resulting coordinates to be multiplied by a constant (default 1).


### Using Moltemplate to trace a polymer along a path

This tool can be useful to help prepare polymer simulations with moltemplate.
Once you have the x,y,z coordinates where you want each monomer to go,
you can use moltemplate to copy and move monomers to this location.
Typically one would prepare a moltemplate input file describing one of
the monomers in the polymer, and then create another file which defines
the polymer.  This polymer file is typically generated by the
[genpoly_lt.py](doc_genpoly_lt.md) program (distributed with moltemplate).
An example of its usage can be found
[here.](http://moltemplate.org/images/misc/polymers_follow_a_curve.png)
*(This file typically contains a combination of
"move()" "rotvv()", "rot()", and "push()" and "pop()" commands.
Those commands are described in chapter 3 of the moltemplate manual.)*



### Example

Use another program to generate a backbone trace for your polymer.
Here we use
[ndmansfield](https://github.com/jewettaij/ndmansfield)
to generate coordinates for a random lattice polymer
("Hamiltonian path") which fills a box of size 53 x 40 x 31
```
ndmansfield -box 53 40 31 -cyclic yes -seed 1  \
            -tsave 200000 -tstop 3200000       \
            > ndmansfield_traj_53x40x31.raw
```
This program uses Monte-Carlo to generate a series of increasingly random
polymer shapes.  As the simulation progresses, the coordinates of the polymer
will be written to a file ("ndmansfield_traj_53x40x31.raw").  This is a
3-column text file (with blank-line delimeters).  It has the following format:

```
x1 y1 z1     #<--1st snapshot in the trajectory
x2 y2 z2
:  :  :
xN yN zN

x1 y1 z1     #<--2nd snapshot in the trajectory
x2 y2 z2
:  :  :
xN yN zN
```
             etc...

*Note: The coordinates generated ndmansfield are nonnegative integers.*

We just need to run the lattice simulation long enough to get a random
polymer conformation.  This duration should be long enough.  (You can check
long enough by watching the messages from ndmansfield printed to the stderr.
The number of bonds in each direction: x,y,z should be approximately equal.)
We want to extract the last frame of this trajectory.  The length of
the lattice polymer in this example is Nx\*Ny\*Nz = 53\*40\*31 = 65720
but we add 1 because there is a blank line separating each frame
```
tail -n 65721 ndmansfield_traj_53x40x31.raw > coords_lattice.raw
```
It might be convenient to center these coordinates before continuing,
so we do that next:
```
recenter_coords.py 0 0 0 < coords_lattice.raw > coords_lattice_cen.raw
```
Suppose we want our final polymer to contain 150000 monomers,
run "interpolate_coords.py" this way:
```
interpolate_mt.py 150000 7.99 < coords_lattice_cen.raw \
      > moltemplate_files/init_crds_center-of-mass-trace.raw
```
This will generate 150000 points at even intervals along this interpolated
path and rescale them so that the separation distance between monomers
is ~3.50, which equals 7.99\*(65720/150000)\*1.  (Recall that the original
space between the points in the "coords_lattice_cen.raw" file is 1.)
